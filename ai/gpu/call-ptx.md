## Call in CUDA/PTX

Given CUDA allow the `__global__` or `__device__` method to call a `__device__` method. so how did it implement?

### No explicit stack
There is no explicit stack in CUDA, which means we could direct access the return address on the stack, like CPU, but the implementation of stacks and local function call management is handled by the SASS (machine-level code) generated by the PTX assembler. The actual hardware (Streaming Multiprocessor or SM) uses a dedicated call stack to manage return addresses for nested function calls.


### PTX code for call
For this code:
```cpp
#include <stdio.h>

__device__ __noinline__ void fooImpl(const int a, const int b){
    printf("blockIdx.x + a: %d\n", blockIdx.x + a);
    printf("threadIdx.x + b: %d\n", threadIdx.x + b);
}

__global__ void foo(
const int a, const int b){
    fooImpl(a, b);
}

int main(){
    dim3 grid(1);
    dim3 block(32);
    foo<<<grid, block>>>(3, 4);
    cudaDeviceSynchronize();
    return 0;
}
```

it's PTX looks like:
```ptx

Fatbin elf code:
================
arch = sm_52
code version = [1,7]
host = linux
compile_size = 64bit

Fatbin elf code:
================
arch = sm_52
code version = [1,7]
host = linux
compile_size = 64bit

Fatbin ptx code:
================
arch = sm_52
code version = [8,5]
host = linux
compile_size = 64bit
compressed
ptxasOptions = 

//
//
//
//
//
//

.version 8.5
.target sm_52
.address_size 64

.extern .func (.param .b32 func_retval0) vprintf
(
.param .b64 vprintf_param_0,
.param .b64 vprintf_param_1
)
;
.global .align 1 .b8 $str[20] = {98, 108, 111, 99, 107, 73, 100, 120, 46, 120, 32, 43, 32, 97, 58, 32, 37, 100, 10};
.global .align 1 .b8 $str$1[21] = {116, 104, 114, 101, 97, 100, 73, 100, 120, 46, 120, 32, 43, 32, 98, 58, 32, 37, 100, 10};

.func _Z7fooImplii(
.param .b32 _Z7fooImplii_param_0,
.param .b32 _Z7fooImplii_param_1
)
{
.local .align 8 .b8 __local_depot0[8];
.reg .b64 %SP;
.reg .b64 %SPL;
.reg .b32 %r<9>;
.reg .b64 %rd<7>;


mov.u64 %SPL, __local_depot0;
cvta.local.u64 %SP, %SPL;
ld.param.u32 %r1, [_Z7fooImplii_param_0];
ld.param.u32 %r2, [_Z7fooImplii_param_1];
add.u64 %rd1, %SP, 0;
add.u64 %rd2, %SPL, 0;
mov.u32 %r3, %ctaid.x;
add.s32 %r4, %r3, %r1;
st.local.u32 [%rd2], %r4;
mov.u64 %rd3, $str;
cvta.global.u64 %rd4, %rd3;
{ //
.reg .b32 temp_param_reg;
.param .b64 param0;
st.param.b64 [param0+0], %rd4;
.param .b64 param1;
st.param.b64 [param1+0], %rd1;
.param .b32 retval0;
call.uni (retval0), 
vprintf, 
(
param0, 
param1
);
ld.param.b32 %r5, [retval0+0];
} //
mov.u32 %r6, %tid.x;
add.s32 %r7, %r6, %r2;
st.local.u32 [%rd2], %r7;
mov.u64 %rd5, $str$1;
cvta.global.u64 %rd6, %rd5;
{ //
.reg .b32 temp_param_reg;
.param .b64 param0;
st.param.b64 [param0+0], %rd6;
.param .b64 param1;
st.param.b64 [param1+0], %rd1;
.param .b32 retval0;
call.uni (retval0), 
vprintf, 
(
param0, 
param1
);
ld.param.b32 %r8, [retval0+0];
} //
ret;

}
//
.visible .entry _Z3fooii(
.param .u32 _Z3fooii_param_0,
.param .u32 _Z3fooii_param_1
)
{
.reg .b32 %r<3>;


ld.param.u32 %r1, [_Z3fooii_param_0];
ld.param.u32 %r2, [_Z3fooii_param_1];
{ //
.reg .b32 temp_param_reg;
.param .b32 param0;
st.param.b32 [param0+0], %r1;
.param .b32 param1;
st.param.b32 [param1+0], %r2;
call.uni 
_Z7fooImplii, 
(
param0, 
param1
);
} //
ret;

}
```

We could see there is a call inst in `foo`:
```
call.uni 
_Z7fooImplii, 
(
param0, 
param1
);
```